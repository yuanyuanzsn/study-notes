# Day01 #

## Dom获取&属性操作 ##


**1.Web API基本认知**
  
   - 变量声明

      - 建议 const优先

         - const语义化更好
         - 有了变量先给const 如果发现它后面是要被修改的 再改为let

      - const声明的值不能更改 而且const声明变量的时候需要里面进行初始化
      - 但是对于引用数据类型 const声明的变量 里面存的不是值 是地址
      - 建议数组和对象使用const来声明

   - API作用和分类

      - 作用：就是使用js去操作html和浏览器
      - 分类：DOM（文档对象模型）、BOM（浏览器对象模型）

   - 什么是DOM

      - DOM（document object model）：是用来呈现以及任意heml或xml文档交互的API  DOM是浏览器提供的一套专门用来操作网页内容的功能
      - 作用：开发网页内容特效和实现用户交互

   - DOM树

      - 将html文档以树状结构直观的表现出来 我们称之为文档树或DOM树
      - 描述网页内容关系的名词
      - 作用：文档树直观的体现了标签与标签之间的关系

   - DOM对象

      - DOM对象：浏览器根据html标签生成的js对象

          - 所有的标签属性都可以在这个对象上找到
          - 修改这个对象的属性会自动映射到标签身上

      - DOM的核心思想：把网页内容当作对象来处理
      - document对象

          - 是DOM李提供的一个对象
          - 所以它提供的属性和方法都是用来访问和操作网页内容的
          - 网页所有内容都在document里面

**2.获取DOM对象**

   - 目标：能查找/获取DOM对象
   - 根据css选择器来获取DOM元素

       - 选择匹配的第一个元素

           - 语法：documen。querySelector（'css选择器'）
           - 参数：包含一个或多个有效的css选择器字符串
           - 返回值：css选择器匹配的第一个元素 一个HTMLElement对象 如果没有匹配到 则返回null

       - 选择匹配的多个元素

           - 语法：documen。querySelectorAll（'css选择器'）
           - 参数：包含一个或多个有效的css选择器字符串
           - 返回值：css选择器匹配的nodelist（对象集合）
           - 得到的是一个伪数组

              - 有长度有索引号的数组
              - 但是没有pop（） push（）等数组方法
              - 想要得到里面的每一个对象 则需要遍历（for）的方式获得

**3.操作元素内容**

  - 目标：能够修改元素的文本更换内容

      - 操作对象使用的点语法
      - 方法：对象.innerText属性 和 对象.innerHTML属性


  - 元素innerText属性

      - 将文本内容添加/更新到任意标签位置
      - 显示纯文本 不解析标签

  - 元素.innerHTML属性

      - 将文本内容添加/更新到任意标签位置
      - 会解析标签 多标签建议使用模板字符

**4.操作元素常用属性**

  - 语法：对象.属性 = 值
  - 操作元素样式属性

     - 通过style属性操作css

         - 语法：对象.style.样式属性 = 值
         - 修改样式通过style属性引出
         - 如果属性有-连接符 需要转换为小驼峰命名法
         - 赋值的时候 需要的时候要加css单位
         - 生成的是行内样式表 权重比较高

     - 操作类名（className）操作css

         - 如果修改的样式比较多 我们可以借助css类名的形式
         - 语法：元素.className = 'active'
         - 由于class是关键字 所以使用className去代替
         - className是使用新值换旧值 如果需要添加一个类 需要保留之前的类名

     - 通过classList操作类控制css

         - 通过classList方式追加和删除类名
         - 语法
           
           - 追加：元素.classList.add('类名')
           - 删除：元素.classList.remove('类名')
           - 切换：元素.classList.toggle('类名')
           - 类名不加点 并且是字符串

     - 操作表单元素属性

         - 获取：DOM对象.属性名
         - 设置：DOM对象.属性名 = 新值
         - 表单属性中添加就有效果,移除就没有效果,一律使用布尔值表示 如果为true 代表添加了该属性 如果是false 代表移除了该属性

     - 自定义属性

         - 标准属性：标签天生自带的属性 可直接使用点语法操作
         - 自定义属性：在html5中推出专门的data-自定义属性
         - 在标签上一律以data开头
         - 在DOM对象上一律以dataset对象方式获取

**5.定时器-间歇函数**

  - 网页中经常会需要一种功能：每隔一段时间自动执行一行代码 不需要我们手动去触发
  - 定时器函数可以开启和关闭定时器

      - 开启定时器

         - 语法：setInterval(函数，间隔时间)
         - 作用：每隔一段时间调用这个函数
         - 间隔时间单位是毫秒
         - 函数名字不需要加括号
         - 定时器返回的是一个id数字

      - 关闭定时器

         - 语法：let 变量名 = setInterval(函数，间隔时间) clearInterval（变量名）

# Day 02 #

## Dom事件基础 ##

**1.事件监听（绑定）**

   - 目标：能给DOM元素添加事件监听
   - 事件：事件是在编程时系统内发生的动作或者发生的事情 比如用户在网页上单击一个按钮
   - 事件监听：就是让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为绑定事件或者注册事件
   - 语法：元素对象.addEventListener('事件类型'，要执行的函数)
   - 事件监听三要素

       - 事件源：哪个dom元素被事件出发了 要获取dom元素
       - 事件类型：用什么方式触发，比如鼠标单击 click、鼠标经过 mouseover 等
       - 事件调用的函数：要做什么事

   - 事件类型要加引号
   - 函数是点击之后再去执行 每次点击都会执行一次

**2.事件类型**

   - 鼠标事件：

       - 鼠标触发
       - click 鼠标点击
       - mouseenter 鼠标经过
       - mouseleave 鼠标离开

  - 焦点事件：

       - 表单获得光标
       - focus 获得焦点
       - blur 失去焦点

  - 键盘事件

       - 键盘触发
       - Keydown 键盘按下触发
       - Keyup 键盘抬起触发

  - 文本事件

       - 表单输入触发
       - input 用户输入事件


**3.事件对象**

  - 获取事件对象

     - 目标：能说出什么是事件对象
     - 事件对象：也是个对象 这个对象里有事件触发时的相关信息
     - 使用场景：可以判断用户按下了哪个键 判断鼠标点击了哪个元素从而做相应的操作
     - 语法：如何获取

         - 在事件绑定的回调函数的第一个参数就是事件对象
         - 一般命名为event、ev、e
         - 元素.addEventListener('click',function(e){})


  - 事件对象属性

      - type：获取当前的事件类型
      - clientX/clientY：获取光标相对于浏览器可见窗口左上角的位置
      - offsetX/offsetY：获取光标相对于当前DOM元素左上角的位置
      - key：用户按下的键盘键的值 现在不提倡使用keyCode

  - trim方法

     - 去除获得的字符串的空格
     - 语法：trim（）


**4.环境对象**

   - 目标：能够分析判断函数运行在不同环境中this所指代的对象
   - 环境对象：值得时函数内部特殊的变量this 它代表着当前函数运行时所处的环境
   - 作用：弄清楚this的指向 可以让我们的代码更简洁
   - 注意

     - 函数的调用方式不同 this指代的对象也不同
     - 【谁调用 this就是谁】 是判断this指向的粗略规则
     - 直接调用函数 其实相当于是window.函数 所以this指代window

**5.回调函数**

  - 目标：能说出什么是回调函数
  - 如果将函数A作为参数传递给函数B时 我们称函数A为回调函数
  - 简单理解：当一个函数当作参数来传递给另一个函数的时候 这个函数就是回调函数
  - 使用场景：使用匿名函数作为回调函数比较常见

# Day03 #
## Dom事件进阶 ##

**1.事件流**  

   - 目标：能够说出事件流经过的2个阶段
   - 事件流指的是事件完整执行过程中的流动路径

       - 说明：假设页面里有个div 当触发事件时会经历两个阶段 分别是捕获阶段和冒泡阶段
       - 简单来说：捕获阶段是从父到子 冒泡阶段是从子到父
       - 实际工作都是使用事件冒泡为主

   - 事件捕获

     - 概念：从DOM的根元素开始去执行对应的事件（从外到里）
     - 事件捕获需要写对应代码才能看到效果
     - 代码：DOM.addEventListener(事件类型，事件处理函数，是否使用捕获机制)
     - 说明

         - addEventListener第三个参数传入true代表是捕获阶段触发（很少使用）
         - 若传入false代表冒泡阶段触发 默认就是false
         - 若是用L0事件监听 则只有冒泡阶段 没有捕获

   - 事件冒泡

     - 目标：能够说出事件冒泡的执行过程
     - 概念：当一个元素的事件被触发时，同样的事件将在该元素的所有祖先元素中依次被触发 这一过程被称为事件冒泡
     - 简单理解：当一个元素出发事件后 会依次向上调用所有父级元素的同名事件
     - 事件冒泡是默认存在的
     - L2事件监听第三个参数是false，或者默认都是冒泡

   - 阻止冒泡

     - 问题：因为默认就有冒泡模式的存在 所以容易导致事件影响到父级元素
     - 需求：若想把事件就限制在当前元素内 就需要阻止事件冒泡
     - 前提：阻止事件冒泡需要拿到事件对象
     - 语法：事件对象.stopPropagation()
     - 注意：此方法可以阻断事件流动传播 不光在冒泡阶段有效 捕获阶段也有效
     - 我们某些情况下需要阻止默认行为的发生，比如 阻止 链接的跳转，表单域跳转

          - 语法：e.preventDefault

   - 解绑事件

     - on事件方式 
    
       - 直接使用null覆盖偶就可以实现事件的解绑
        - 语法：btn.onclick = function() {alert('点击了')} btn.onclick = null

     - addEventListener方式

         - 必须使用removeEventListener（事件类型，事件处理函数，【获取捕获或者冒泡阶段】）
         - 匿名函数无法被解绑
         
   - 鼠标经过事件的区别

       - mouseover和mouseout会有冒泡效果
       - mouseenter和mouseleave没有冒泡效果（推荐）

   - 两种注册事件的区别
   
       - 传统on注册（L0）
     
         - 同一个对象 后面注册的事件会覆盖前面注册（同一事件）
         - 直接使用null覆盖偶就可以实现事件的解绑
         - 都是冒泡阶段执行的
        

       - 事件监听注册（L2）
       
          - 语法：addEventerListener（事件类型，事件处理函数，是否使用捕获） 
          - 后面注册的事件不会覆盖前面注册的事件（同一事件）
          - 可以通过第三个参数去确定是在冒牌或者捕获阶段执行
          - 必须使用removeEventListener（事件类型，事件处理函数，【获取捕获或者冒泡阶段】）
          - 匿名函数无法被解绑
          

**2.事件委托**

   - 事件委托是利用事件流的特征解决一些开发需求的知识技巧

     - 优点：减少注册次数 可以提高程序性能
     - 原理：事件委托其实是利用事件冒泡的特点 给父元素注册事件 当我们触发子元素的时候 会冒泡到父元素身上 从而触发父元素的事件
     - 实现：事件对象.target.tagName可以获得真正触发事件的元素
     

**3.其他事件**

  - 页面加载事件

     - 加载外部资源（如图片、外联CSS和js等）加载完毕时触发的事件
      - 事件名：load
      - 监听页面所有资源加载完毕
      - 注意：不光可以监听整个页面资源加载完毕 也可以针对某个资源绑定load事件

  - 当初始的html文档被完全加载和解析完成之后 DOMContentLoaded事件被触发 而无需等待样式表、图像等完全加载

     - 事件名：DOMContentLoaded
     - 监听页面DOM加载完毕
     
  - 页面滚动事件

      - 滚动条在滚动的时候持续触发的事件
      - 事件名：scroll
      - 给windows或document添加scroll事件
      - 监听某个元素的内部滚动直接给某给元素加即可
      - 获取位置

         - scrollLeft和scrollTop（属性）

             - 获取被卷去的大小
             - 获取元素内容往左、网上滚出去看不到的距离
             - 这两个值是可读写的

         - 尽量在scroll事件里面获取被卷去的距离
         - 检测页面滚动的头部距离（被卷去的头部）属性：document.documentElement.scrollTop

      - 页面滚动到指定的坐标

         - scrollTo（）方法可以把内容滚动到指定的坐标
         - 语法：元素.scrollTo(x,y)

  - 页面尺寸事件

     - 会在窗口尺寸改变的时候触发的事件
     - resieze
     - 检测屏幕宽度
     - 获取宽高

         - 获取元素的可见部分宽高（不包含边框 margin 滚动条等）
         - clientWidth和clientHeight

**4.元素尺寸与位置**

  - 使用场景

     - 前面案例滚动多少距离都是我们自己算的 最好是页面滚动到某个元素 就可以做某些事 
     - 简单说就是通过js的方式 得到元素在页面中的位置 
     - 这样我们就可以当页面滚动到这个位置时做某些操作 省去计算了

  - 获取宽高

     - 获取元素的自身宽高 包含元素自身设置的宽高、padding、border
     - offsetWidth和offsetHeight
     - 获取出来的时数值 方便计算
     - 注意：获取的是可视宽高 如果盒子是隐藏的 获取的结果是0

  - 获取位置方法1

     - 获取元素距离自己定位父级元素的左、上距离
     - offsetLeft和offsetTop注意是只读属性

  - 获取位置方法2

     - element。getBoundingClientRect（）
     - 方法返回元素的大小及其相对于视口的位置


# Day 04 #

## Dom节点 & 移动端滑动 ##

**1.日期对象**

   - 目标：掌握日期对象 可以让网页显示日期
   - 日期对象：用来表示时间的对象
   - 作用：可以得到当前系统时间
   - 实例化
  
     - 目标：能够实例化日期对象
     - 在代码中发现了new关键字时 一般将这个操作称为实例化
     - 创建一个时间对象并获取时间

         - 获得当前时间：const date = new Date()
         - 获得指定时间：const date = new Date('2008-8-8')

   - 日期对象方法

     - 目标:能够使用日期对象中的方法写出常见日期
     - 使用场景：因为日期返回的数据我们不能直接使用 所以需要转换为实际开发中常用的格式
     - getFullYear（）：获得年份 获取四位年份
     - getMonth（）：获得月份 取值为0-11
     - getDate（）：获取月份中的每一天 不同月份取值也不相同
     - getDay（）：获取星期 取值为0-6
     - getHours（）：获取小时 取值为0-23
     - getMinutes（）：获取分钟 取值为0-59
     - getSeconds（）：获取秒 取值为0-59

   - 时间戳

     - 目标：能够获得当前时间戳
     - 使用场景：如果计算倒计时效果 前面方法无法直接结算 需要借助于时间戳完成
     - 时间戳是指1970年01月01日00时00分00秒起至现在的毫秒数 它是一种特殊的计量时间的方式
     - 算法

        - 将来的时间戳 - 现在的时间戳 = 剩余时间毫秒数
        - 剩余时间毫秒数 转换为 剩余时间的年月日时分秒就是倒计时时间
        - 比如 将来时间戳2000ms - 现在时间戳1000ms = 1000ms
        - 1000ms 转换为就是 0小时0分1秒

     - 三种方法获取时间戳

        - const date = new Date() console.log(date.getTime())
        - 简写 + new Date()  无需实例化
        - 使用Date.now() 

             - 无需实例化
             - 但是只能得到当前的时间戳 而前面两种可以返回指定的时间戳

**2.节点操作**

   - DOM节点

      - 目标：能说出DOM节点的类型
      - DOM节点：DOM树里每一个内容都称之为节点
      - 节点类型

         - 元素节点：所有标签 html是根节点（重点记）
         - 属性节点：所有的属性
         - 文本节点：所有的节点
         - 其他

   - 查找节点

      - 目标：能够具备根据节点关系查找目标节点的能力
      - 节点关系：针对的找亲戚返回的都是对象
      - 父节点

          - parentNode属性
          - 返回最近一级的父节点 找不到返回为null
          - 子元素.parentNode
      - 子节点

          - childNodes：获得所有子节点 包括文本节点（空格、换行） 注释节点等
          - children属性（重点）：仅获得所有元素节点 返回的还是一个伪数组
          - 父元素.children
      - 兄弟节点
 
          - 下一个兄弟节点：nextElementSibling 属性
          - 上一个兄弟节点：previousElementSibling 属性

   - 增加节点

       - 目标：能够具备根据需求新增节点的能力
       - 新增节点：创建一个新的节点 把创建的新的节点放入到指定的元素内部
       - 创建节点

           - 即创造出一个新的网页元素 再添加到网页内 一般先创建节点 然后插入节点
           - 方法：documen.creatElement('标签名')

       - 追加节点

           - 插入到父元素的最后一个子元素：父元素.appendChild(要插入的元素)
           - 插入到父元素中某个子元素的前面：父元素.insertBefore(要插入的元素，在哪个元素前面)
           - 克隆节点：元素.cloneNode(布尔值)

              - cloneNode会克隆出一个跟原标签一样的元素 括号内传入布尔值
              - 若为true 则代表克隆时会包含后代节点一起克隆
              - 若为false 则代表克隆时不包含后代节点
              - 默认为false

   - 删除节点

       - 目标：能够具备根据需求删除节点的能力
       - 若一个节点在页面中已不需要时 可以删除它
       - 在js原生DOM操作中 要删除元素必须通过父元素删除
       - 语法:父元素.removeChild(要删除的元素)
       - 注意

          - 如不存在父子关系则删除不成功
          - 删除节点和隐藏节点有区别的：隐藏节点还是存在的 但是删除 则从html中删除节点

**3.M端事件**

   - 目标：了解M端常见的事件
   - 触屏事件touch(也称触摸事件) Adroid和IOS都有
   - touch对象代表一个触摸点 
   - touchstart：手指触摸到一个DOM元素时触发
   - touchmove：手指在一个DOM元素上滑动时触发
   - touched：手指从一个DOM元素上移开时触发

**4.插件**

   - 插件：就是别人写好的一些代码 我们只需要复制对应的代码 就可以直接实现对应的效果
   - 学习插件的基本过程

       - 熟悉官网,了解这个插件可以完成什么需求 https://www.swiper.com.cn/
       - 看在线演示,找到符合自己需求的demo https://www.swiper.com.cn/demo/index.html
       - 查看基本使用流程 https://www.swiper.com.cn/usage/index.html
       - 查看APi文档,去配置自己的插件 https://www.swiper.com.cn/api/index.html
       - 注意: 多个swiper同时使用的时候, 类名需要注意区分

# Day05 #

## Bom操作 ##


**1.window对象**

   - BOM（Browser Object Model）是浏览器对象模型
 
       - window对象是一个全局对象 也可以说是js中的顶级对象
       - 像documen、alert（）、console.log（）这些都是window的属性 基本BOM的属性和方法都是window的
       - 所有通过var定义在全局作用域中的变量 函数都会变成window对象的属性和方法
       - window对象下的属性和方法调用的时候可以省略window
       
   - 定时器-延时函数

       - js内置的一个用来让代码延迟执行的函数 叫setTimeout
       - 语法：setTimeout(回调函数，等待的毫秒数)
       - setTimeout仅仅只执行一次 所以可以理解为就是把一段代码延迟执行 平时省略window
       - 清除延时函数：let timer = setTimeout(回调函数，等待的毫秒数) clearTimeout（timer）
       - 注意点

           - 延时器需要等待 所以后面的代码先执行
           - 每一次调用延时器都会产生一个新的延时器

   - 两种定时器对比

       - 延时函数：执行一次
       - 间歇函数：每隔一段时间就执行一次 除非手动清除

   - js执行机制

       - js语言的一大特点就是单线程 也就是说 同一个时间只能租一件事
       - 同步和异步：本质区别在于各个流程的执行顺序不同
       - 同步任务：同步任务都在主线程上执行 形成一个执行栈
       - 异步任务：js的异步是通过回调函数实现的

           - 普通事件：click、resize等
           - 资源加载：load、error等
           - 定时器：包括setinterval、setTimeout等
           - 异步任务相关添加到任务队列中（任务队列也成为消息队列）

       - 执行机制

           - 先执行执行栈中的同步任务
           - 异步任务放入任务队列中 
           - 一旦执行栈中的所有同步任务执行完毕 系统就会按次序读取任务队列中的异步任务 于是被读取的异步任务结束等待状态 进入执行栈 开始执行
           - 由于主线程不断地重复获得任务 执行任务 再获取任务 再执行 所以这种机制被称为事件循环（event loop）

  - location对象

     - location的数据类型是对象 它拆分并保存了URL地址的各个组成部分
     - 常用属性和方法

       - href属性获取完整的URL地址 对其赋值时用于地址的跳转

          - console.log(location.href) location.href = 'http://...'
       - search属性获取地址中携带的参数 符号？后面部分

          - console.log(location.search)
       - hash属性获取地址中的哈希值 符号#后面部分

          - console.log(location.search)
          - 后期vue路由的铺垫 经常用于不刷新页面 显示不同页面
       - reload方法用来刷新当前页面 传入参数true时表示强制刷新

          - location.reload()

  - navigator对象

    - navigator的数据类型是对象 该对象记录了浏览器自身的相关信息
    - 常用属性和方法

     - 通过 userAgent 检测浏览器的版本及平台
     - // 检测 userAgent（浏览器信息）
    !(function () {
    const userAgent = navigator.userAgent
    // 验证是否为Android或iPhone
    const android = userAgent.match(/(Android);?[\s\/]+([\d.]+)?/)
    const iphone = userAgent.match(/(iPhone\sOS)\s([\d_]+)/)
    // 如果是Android或iPhone，则跳转至移动站点
    if (android || iphone) {
    location.href = 'http://m.itcast.cn' }
    })()

  - history对象

      - history的数据类型是对象 主要管理历史记录 该对象与浏览器地址栏的操作相对应 如前进 后退 历史记录等
      - 常用属性和方法

         - back（）：可以后退功能
         - forward（）：前进功能
         - go（参数）：前进后退功能 参数如果是1前进1个页面 如果是-1 后退1个页面

       - 在实际开发中比较少用

**2.本地储存**

   - 本地存储介绍

      - 数据存储在用户浏览器中
      - 设置 读取方便 甚至页面刷新不丢失数据
      - 容量较大 sessionStorage和localStorage约5M左右

   - 本地存储分类

      - localStorage：可以将数据永久存储再本地 除非手动删除 否则关闭页面也会存在
        - 特性

         - 可以多窗口（页面）共享（同一浏览器可以共享）
         - 以键值对的形式存储使用

        - 语法

         - 存储数据：localStorage.setItem(key,value)
         - 获取数据：localStorage.getItem(key)
         - 删除数据：localStorage.removeItem(key)

        - 查看本地数据：F12-Application-LocalStorage
        - 本地存储只能存储字符串类型

      - sessionStorage 特性

        - 生命周期为关闭浏览器窗口
        - 在同一个窗口（页面）下数据可以共享
        - 以键值对的形式存储使用
        - 用法跟localStorage基本相同

   - 存储复杂数据类型

      - 目标：能够存储复杂数据类型以及取出数据
      - 本地存储只能存储字符串 不能存储复杂数据类型 需要将复杂数据类型转换成JSON字符串 再存储到本地
      - 语法：JSON.stringify(复杂数据类型) 
      - 将复杂数据转换成JSON字符串存储本地存储中
      - 把取出来的字符串转换为对象
      - 语法：JSON.parse(JSON字符串)  

   - 数组中map方法 迭代数组

       - 使用场景：map可以遍历数组处理数据 并且返回新的数组

   - 数组中join方法

       - 作用：join（）方法用于把数组中的所有元素转换为以一个字符串
       - 语法：const arr = 【】  console.log(arr.join(''))
       - 参数：数组元素是通过参数里面指定的分隔符进行分隔的  

# Day 06 #

## 正则&阶段案例 ##

**1.正则表达式**

  - 正则表达式（regular expression）是用于匹配字符串中字符组合的模式 在js中 正则表达式也是对象
    - 通常用来查找 替换那些符合正则表达式的文本 许多语言都支持正则表达式
    - 使用场景：表单验证（匹配） 过滤敏感词（替换） 字符串中提取我们想要的部分（提取）

  - 语法

     - 定义正则表达式：const 变量名 = /表达式/ 其中/ /是正则表达式字面量
     - 判断是否有符合规则的字符串：test（）方法 用来查看正则表达式与指定的字符串是否匹配
      - 如果正则表达式与指定的字符串匹配 返回true 否则false

     - 检索（查找）符合规则的字符串：exec（）方法 在一个指定字符串中执行一个搜索匹配
       
         - 如果匹配成功 exec（）方法返回一个数组 否则返回null

  - 元字符

     - 目标：能说出什么是元字符以及它的好处
     - 普通字符：大多数的字符能够描述它们本身 这些字符称作普通字符
     - 元字符（特殊字符）：是一些具有特殊含义的字符 可以极大提高灵活性和强大的匹配功能

         - 边界符：表示位置 开头和结尾 必须用什么开头 用什么结尾

             - 正则表达式中的边界符（位置符）用来提示字符所处的位置 主要有两个字符
             - ^表示匹配行首的文本（以谁开始）
             - $表示匹配行尾的文本（以谁结束）
             - 如果^和$在一起 表示必须是精确匹配
         - 量词：表示重复次数

             - 量词用来设定某个模式出现的次数
             - * 重复零次或更多次
             - + 重复一次或更多次
             - ？ 重复零次或一次
             - {n} 重复n次
             - {n，} 重复n次或更多次
             - {n，m} 重复n到m次
             - 注意：逗号左右两侧千万不要出现空格
         - 字符类：比如\d 表示0~9

             - 【】匹配字符集合：后面的字符串只要包含【】中任意一个字符 都返回true
             - 【】里面加上-连字符

                  - 使用连字符- 表示一个范围
                  - 【a-z】表示a-z26个英文字母都可以
                  - [a-zA-Z] 表示大小写都可以
                  - [0-9] 表示 0~9 的数字都可以

             - 【】里面加上^取反号

                  - [0-9] 表示 0~9 的数字都可以
                  - 注意要写到中括号里面

             - . 匹配除换行符之外的任何单个字符
             - 预定义：指的是某些常见模式的简写方式

                  - \d 匹配0-9之间的任一数字 相当于【0-9】
                  - \D 匹配所有0-9以外的字符 相当于【^0-9】
                  - \w 匹配任意的字母 数字和下划线 相当于【a-zA-Z0-9_】
                  - \W 除所有字母 数字和下划线以外的字符 相当于【^a-zA-Z0-9_】
                  - \s 匹配空格（包括换行符 制表符 空格符等） 相当于【\t\r\n\v\f】
                  - \S 匹配非空格的字符 相当于【^\t\r\n\v\f】

  - 修饰符

      - 修饰符约束正则执行的某些细节行为 如是否区分大小写 是否支持多行匹配等
      - 语法：/表达式/修饰符
         - i是单词ignore的缩写 正则匹配时字母不区分大小写
         - g是单词global的缩写 匹配所有满足正则表达式的结果

      - 替换replace

         - 字符串.replace(/正则表达式/，'替换的文本')
       
       
        
      
             
     