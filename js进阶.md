# Day 01 #

## 作用域&解构&箭头函数 ##


**1.作用域**


   - 目标：了解作用域对程序执行的影响及作用域链耳朵查找机制 使用闭包函数创建隔离作用域避免全局变量污染
       - 作用域规定了变量能被访问的范围 离开了这个范围变量便不能被访问
       - 作用域分为局部作用域和全局作用域

   - 局部作用域

       - 函数作用域

           - 在函数内部声明的变量只能在函数内部被访问 外部无法直接访问
           - 函数的参数也是函数内部的局部变量
           - 不同函数内部声明的变量无法互相访问
           - 函数执行完毕后 函数内部的变量实际被清空了
       - 块作用域

           - 在js中使用{}包裹的代码称为代码块 代码块内部声明的变量外部将有可能无法被访问
           - let声明的变量会产生块作用域 var不会产生块作用域
           - const声明的常量也会产生块作用域
           - 不同代码块之间的变量无法互相访问
           - 推荐使用let或const


   - 全局作用域

      -  在`<script>`标签和.js文件的最外层就是全局作用域 在此声明的变量在函数内部也可以被访问
      - 全局作用域中声明的变量 任何其他作用域都可以被访问
      - 注意

         - 为window对象动态添加的属性默认也是全局的 不推荐
         - 函数中未使用任何关键字声明的变量为全局变量 不推荐
         - 尽可能少的声明全局变量 防止全局变量被污染

   - 作用域链

      - 作用域链本质上是底层的变量查找机制
      - 在函数被执行时 会优先查找当前函数作用域中查找变量
      - 如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域
      - 总结

         - 嵌套关系的作用域串联起来形成了作用域链
         - 相同作用域链中按着从小到大额规则查找变量
         - 子作用域能访问父作用域 父级作用域无法访问子级作用域

   - js垃圾回收机制

      - 目标：了解js垃圾回收机制的执行过程
      - （Gaebage Collection）简称GC：js中内存的分配和回收都是自动完成的 内存在不适用的时候会被垃圾回收器自动回收 不再用到的内存 没有及时释放 就叫做内存泄漏
      - 内存的生命周期

         - 内存分配：当我们声明变量 函数 对象的时候系统会自动为他们分配内存
         - 内存使用：即读写内存 也就是使用变量 函数等
         - 内存回收：使用完毕 由垃圾回收自动回收不再使用的内存
         - 说明

             - 全局变量一般不会回收（关闭页面回收）
             - 一般情况下局部变量的值 不用了 会被自动回收掉

      - 算法说明

         - 堆栈空间分配区别

             - 栈（操作系统）：由操作系统自动分配释放函数的参数值 局部变量等 基本数据类型放到栈里面
             - 堆（操作系统）：一般由程序员分配释放 若程序员不是放 由垃圾回收机制回收 复杂数据类型放到堆里面

         - 引用计数法

             - IE采用的引用技术算法 定义内存不再使用 就是看一个对象是否由指向它的引用 没有引用了就回收对象
             - 跟踪记录被引用的次数
             - 如果被引用了依次 那么就记录次数1 多次引用会累加++
             - 如果减少一个引用就减1 --
             - 如果引用次数时0 则释放内存
             - 存在一个问题：嵌套引用（循环引用）即两个对象相互引用

         - 标记清除法

             - 标记清除算法将不再使用的对象定义为无法达到的对象
             - 就是从根部（在js中就是全局对象）出发定时扫描内存中的对象 凡是能从根部到达的对象 都是还需要使用的
             - 那些无法由根部出发触及到的对象被标记为不再使用 稍后进行回收

     - 闭包

         - 目标：能说出什么是闭包 必报的作用以及注意事项
         - 概念：一个函数对周围状态的引用捆绑在一起 内层函数中访问到其外层函数的作用域
         - 简单理解：闭包 = 内层函数 + 外层函数的变量
         - 作用：封闭数据 提供操作 外部也可以访问函数内部的变量
         - 应用：实现数据的私有 比如我们要做个统计函数调用次数 函数调用一次 就++

     - 变量提升

         - 目标：了解什么是变量提升
         - 变量提升时js中比较奇怪的现象 它允许在变量声明之前即被访问（仅存在于var声明变量）
         - 流程

             - 先把var变量提升到当前作用域最前面
             - 只提升变量声明 不提升变量赋值
             - 然后依次执行代码
         - 注意

             - 变量在未声明即被访问时会包语法错误
             - 变量在var声明之前即被访问 变量的值未undefined
             - let/const 声明的变量不存在变量提升
             - 变量提升出现在相同作用域当中
             - 实际开发中推荐先声明再访问变量

**2.函数进阶**

   - 函数提升

       - 函数提升与变量提升比较类似 是指函数在声明致歉即可被调用
       - 函数提升能够使函数的声明调用更灵活
       - 函数表达式不存在提升的现象
       - 函数提升出现在相同作用域中

   - 函数参数

       - 动态参数：arguments是函数内部内置的伪数组变量 它包含了调用函数时传入的所有实参

          - arguments是一个伪数组 只存在于函数中
          - arguments的作用是动态获取函数的实参
          - 可以通过for循环依次得到传递过来的实参

      - 剩余参数

          - 剩余参数允许我们将一个不定数量的参数表示为一个数组
          - ...是语法符号 置于最末函数形参之前 用于获取多余的实参
          - 借助...获取的剩余实参 是个真数组
          - 开发中 还是提倡多使用剩余实参

      - 展开运算符

        - 展开运算符（...） 将一个数组进行展开
        - 不会修改原数组
        - 典型运用场景：求数组最大值最小值 合并数组等
      
      - 箭头函数
      
        - 目的：引入箭头函数的目的是更简短的函数写法并且不绑定this 箭头函数的语法比函数表达式更简洁
        - 使用场景：箭头函数更适用于那些本来需要匿名函数的地方
        - 基本语法
             - 只有一个参数可以省略小括号
             - 如果函数体只有一行代码 可以写到一行上 并且无需写return直接返回值
             - 加括号的函数体返回对象字面量表达式

        - 箭头函数参数

             - 普通函数有arguments动态参数 箭头函数没有arguments动态参数 但是有剩余参数...args
        
        - 箭头函数this

             - 箭头函数不会创建自己的this 它只会从自己的作用域链的上一层沿用this
             - 在开发中【使用箭头函数前需要考虑函数中this的值】 事件回调函数使用箭头函数时 this为全局的window 因此DOM事件回调函数为了简便 还是不太推荐使用箭头函数

**3.解构赋值**

   - 目标：知道解构的语法及分类 使用解构简洁语法快速为变量赋值
   - 数组解构

       - 数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法
       - 基本语法

           - 赋值运算符 = 左侧的 【】 用于批量声明变量 右侧数组的单元值将被赋值给左侧的变量
           - 变量的顺序对应数组单元值的位置依次进行赋值操作
           - 变量的数量大于单元值数量时 多余的变量将被赋值为 undefined
           - 利用剩余参数解决变量少 单元值多的情况 
           - 防止有undefined传递单元值的情况 可以设置默认值（允许初始化变量的默认值 且只有单元值为undefined时默认值才会生效）
           - 按需导入 忽略某些返回值
           - 支持多维数组的结构

       - js前面必须加分号的两种情况

           - 立即执行函数
           - 数组解构

   - 对象解构

       - 对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法
       - 基本语法

           - 赋值运算符 = 左侧的 {} 用于批量声明变量 右侧对象的属性值将被赋值给左侧的变量
           - 对象属性的值将被赋值给与属性名相同的变量
           - 注意解构的变量名不要和外面的变量名冲突否则报错
           - 对象中找不到与变量名一致的属性时变量值为undefined

       - 给新的变量名赋值

           - 可以从一个对象中提取变量并同时修改新的变量名
           - 给新的变量名赋值：可以从一个对象中提取变量并同时修改新的变量名 冒号表示'什么值：赋值给谁'
           - 解构数组对象
           - 多级对象解构

   - 遍历数组forEach方法

       - 用于调用数组的每个元素 并将元素传递给回调函数
       - 主要使用场景：遍历数组的每个元素
       - 语法：被遍历的数组.forEach（function（当前数组元素， 当前元素索引号）{}）
       - 参数当前数组元素时必须要写的 索引号可选

# Day 02 #
## 构造函数&数据常用函数 ##

**1.深入对象**

  - 创建对象三种方式

      - 利用对象字面量创建对象
      - 利用new Object创建对象
      - 利用构造函数创建对象

  - 构造函数

      - 是一种特殊的函数 主要用来初始化对象
      - 命名以大写字母开头 只能由new操作符来执行
      - 说明

         - 使用new关键字调用函数的行为被称为实例化
         - 实例化构造函数时没有参数时可以省略（）
         - 构造函数内部无需写return 返回值即为新创建的对象
         - 构造函数内部的return返回的值无效 所以也不要写retuen
         - new Object() new Date()也是实例化构造函数

      - 实例化执行的过程

         - 创建新空对象
         - 构造函数this指向新对象
         - 执行构造函数代码 修改this 添加新的属性
         - 返回新对象

  - 实例成员&静态成员

     - 通过构造函数创建的对象称为实例对象 实例对象中的属性和方法称为实例成员

         - 为构造函数传入参数 动态创建结构相同但值不同的对象
         - 构造函数创建的实例对象彼此独立互不影响

     - 构造函数的属性和方法被称为静态成员

         - 一般公共特征的属性或方法设置为静态成员
         - 静态成员方法中的this指向构造函数本身

**2.内置构造函数**

  - 在js中最主要的数据类型有6种
   
     - 基本数据类型：字符串 数值 布尔 null undefined
     - 引用类型：对象
     - 其实字符串 数据 布尔等基本类型也有专门的构造函数 这些我们称为包装类型
     - js中几乎所有的数据都可以基于构造函数创建
     - 引用类型：Object Array RegExp Date
     - 包装类型：String Number Boolean

  - Object是内置的构造函数 用于创建普通对象

     - 学习常用的三个静态方法

       - Object.keys静态方法获取对象中所有属性（键）

             - 语法：const arr = Object.keys(对象名)
             - 注意返回的是一个数组
             
       - Object.values静态方法获取对象中所有的属性值
            
             - 语法：const arr = Object.values(对象名)
             - 注意返回的是一个数组

       - Object.assign静态方法常用于对象拷贝

             - 语法：Object.assign(obj, 对象名)
             - 使用：经常使用的场景给对象添加属性

  - Array是内置的构造函数 用于创建数组

     - 数组常见实例方法-核心方法

         - forEach 遍历数组 不反悔 用于不改变值 经常用于查找打印输出值
         - filter 过滤数组 筛选数组元素 并生成新数组
         - map 迭代数组 返回新数组 新数组里面的元素是处理之后的值 经常用于处理数据
         - reduce 累计器 返回函数累计处理的结果 经常用于求和等

     - 基本语法： arr.reduce(function() {}, 起始值)
     - 参数：起始值可以省略 如果写就作为第一次累计的起始值
     - 语法：arr.reduce(function(累计值，当前元素【，索引号】【，源数组】){}，起始值)
     - 累计参数值

         - 如果有起始值 则以起始值为准开始累计 累计值 = 起始值
         - 如果没有起始值 则累计值以数组的第一个元素作为起始值开始累计
         - 后面每次遍历就会用后面的数组元素 累积到累计值里面（类似于求和里面的sum）

     - 使用场景：求和运算
     - 数组常见方法-其他方法

         - 实例方法join数组元素拼接为字符串 返回字符串（重点）
         - 实例方法find查找元素 返回符合测试条件的第一个数组元素 如果没有则返回undefined（重点）
         - 实例方法every拣择数组中所有元素是否都符合指定条件如果所有元素都满足条件则返回true 否则返回false（重点）
         - 实例方法some检测数组中的元素是否满足指定条件 如果数组中铀元素满足条件返回true 否则返回false
         - 实例方法contact 合并两个数组 返回生成新数组
         - 实例方法sort 对原数组单元值排序
         - 实例方法splice 删除或替换原数组单元
         - 实例方法reverse 返回数组
         - 实例方法findIndex 查找元素的索引值

     - 数组常见方法-伪数组转换为真数组

         - 静态方法Array.from()
         
  - String

     - 在js中的字符串 数值 布尔具有对象的使用特征 如具有属性和方法 之所以具有对象特征的原因是字符串 数值 布尔类型数据是js底层使用Object构造函数 包装 来的 被称为包装类型
     - 常见实例方法

         - 实例属性length用来获取字符串的度长（重点）
         - 实例方法split（'分隔符'）用来将字符串拆分成数组（重点）
         - 实例方法substring（需要截取的第一个字符的索引【，结束的索引号】）用于字符串截取（重点）
         - 实例方法startWith（检测字符串【，检测位置索引号】）检测是否以某字符开头（重点）
         - 实例方法includes（搜索的字符串【，检测位置索引号】）判断一个字符串是否包含在另一个字符串中 根据情况返回true或false（重点）
         - 实例方法tuUpperCase 用于将字母转换成大写
         - 实例方法toLowerCase 用于将字母转换成小写
         - 实例方法indexOf 检测是否包含某字符
         - 实例方法endsWith 检测是否以某字符结尾
         - 实例方法replace 用于替换字符串 支持正则匹配
         - 实例方法match 用于查找字符串 支持正则匹配

  - Number

     - Number是内置的构造函数 用于创建数值
     - 常用方法：toFixed（）设置保留小数位的长度 四舍五入

# Day 03 #

## 深入面向对象 ##


**1.编程思想**


  - 面向过程编程

      - 面向过程就是分析出解决问题所需要的步骤 然后用函数把这些步骤一步一步实现 使用的时候再一个一个的调用就可以了
      - 面向过程 就是按照我们分析好了的步骤 按照步骤解决问题

  - 面向对象编程（opp）

      - 面向对象是把事务分解成一个个对象 然后由对象之间分工与合作
      - 面向对象是以对象功能来划分问题 而不是步骤
      - 每一个对象都是功能中心 具有明确分工
      - 特性：封装性 继承性 多态性

**2.构造函数**

  - 封装是面向对象思想中比较重要的一部分 js面向对象可以通过构造函数实现的封装
  - 同样的将变量和函数组合到了一起并能通过this实现数据的共享 所不同的是借助构造函数创建出来的实例对象之间是彼此不影响的
  - 存在浪费内存的问题
  

**3.原型**

  - 目标：能够利用原型对象实现方法共享
  - 原型
    - 构造函数通过原型分配的函数是所有对象所共享的
    - js规定 每一个构造函数都有一个prototy属性 指向另一个对象 所以我们也称为原型对象
    - 这个对象可以挂载函数 对象实例化不会多次创建原型上函数 节约内存
    - 我们可以把那些不变的方法 直接定义在protot对象上 这样所有对象的实例就可以共享这些方法
    - 构造函数和原型对象中的this都指向实例化的对象

  - constructor属性

     - 在每个原型对象里面都有个constructor属性（constructor构造函数）
     - 该属性指向该原型对象的构造函数 简单理解 就是指向我的爸爸 我是有爸爸的孩子
     - 使用场景：如果有多个对象的方法 我们可以给原型对象采取对象形式赋值 但是这样就会覆盖构造函数原型对象原来的内容 这样修改后的原型对象 constructor 就不再指向当前构造函数了 此时 我们可以在修改后的原型对象中 添加一个 constructor 指向原来的构造函数

  - 对象原型

     - 对象都会有一个属性 __proto__ 指向构造函数的 prototype原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。
     - 注意

         - __proto__ 是JS非标准属性
         - [[prototype]]和__proto__意义相同
         - 用来表明当前实例对象指向哪个原型对象prototype
         - __proto__对象原型里面也有一个 constructor属性，指向创建该实例对象的构造函数

  - 原型继承

     - 继承是面向对象编程的另一个特称 通过继承进一步提升代码封装的程度 js中大多是借助原型对象实现继承的特性

  - 原型链

     - 基于原型对象的继承使得不同构造函数的原型对象关联在一起 并且这种关联的关系是一种链状的结构 我们将原型对象的链状结构关系称为原型链
     - 查找规则

        - 当访问一个对象的属性（包括方法）时 首先查找这个对象自身有么有该属性
        - 如果没有就查找它的原型（也就是__proto__指向的prototy原型对象）
        - 如果还没有就查找原型对象的原型（Object的原型对象）
        - 以此类推一直找到Object为止（null）
        - __proto__对象原型的意义就在于为对象成员查找机制提供一个方向 或者说一条路线
        - 可以使用instanceof运算符用于检测构造函数的prototy属性是否出现在某个实例对象的原型链上


# Day04 #

## 高阶技巧 ##

**1.深浅拷贝**

  - 浅拷贝：拷贝的是地址

     - 如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 (简单理解： 如果是单层对象，没问题，如果有多层就有问题)
     - 拷贝对象之后 里面的属性值是简单数据类型直接拷贝值
     - 如果属性值是引用数据类型则拷贝的是地址

  - 深拷贝

     - 通过递归实现深拷贝

         - 函数递归：如果一个函数在内部可以调用其本身 那么这个函数就是递归函数
         - 简单理解：函数内部自己调用自己 这个函数就是递归函数
         - 递归函数的作用和循环效果类似
         - 由于递归很容易发生栈溢出错误（stack overflow） 所以必须要加退出条件 return
         - 利用递归函数实现setTimeout模拟setInterval效果

     - js库lodash里面的cloneDeep内部实现了深拷贝

         - 语法：_.cloneDeep（obj）

     - 通过JSON.stringigy（）实现

**2.异常处理**

   - 异常处理是指预估代码执行过程中可能发生的错误 然后最大程度的避免错误的发生导致整个程序无法继续运行
   - throw抛异常

      - throw抛出异常信息 程序也会终止
      - throw后面跟的是错误提示信息
      - Error对象配合throw使用 呢狗设置更详细的错误信息

   - try/catch捕获错误信息

      - 我们可以通过try / catch 捕获错误信息（浏览器提供的错误信息） try 试试 catch 拦住 finally 最后
      - try...catch用于捕获错误信息
      - 将预估可能发生错误的代码写在try代码段中
      - 如果try代码段中出现错误后 会执行catch代码段 并截获到错误信息
      - finally不管是否有错误 都会执行

  - debugger

**3.处理this**

  - this指向-普通函数

     - 普通函数的调用方式决定了this的值 即 谁调用this的指向指向谁
     - 普通函数没有明确调用者时this值为window  严格模式下没有调用者时this的值为undefined

  - this指向-箭头函数

     - 箭头函数中的this与普通函数完全不同 也不受调用方式的影响 事实上箭头函数中并不存在this
     - 箭头函数会默认帮我们绑定外层this的值 所以在箭头函数中this的值和外层的this是一样的
     - 箭头函数中的this引用的就是最近作用域中的this
     - 向外层作用域中 一层一层查找this 直到有this的定义
     - 注意情况

         - 在开发中【使用箭头函数前需要考虑函数中的this的值】 事件回调函数使用箭头函数时 this为全局的window 因此DOM时间回调函数吐过里面需要DOM对象的this  则不推荐使用箭头函数
         - 由于箭头函数this的原因 基于原型的面向对象也不推荐采用箭头函数
         - 构造函数 原型函数 dom时间函数不适用

  - 改变this

     - JavaScript 中还允许指定函数中 this 的指向，有 3 个方法可以动态指定普通函数中 this 的指向
     - call（） -了解

         - 使用call方法调用函数 同时指定被调用函数中this的值
         - 语法：fun.call(thisArg,arg1,arg2,...)
         - thisArg:在fun函数运行时指定的this值
         - arg1，arg2：传递的其他参数
         - 返回值就是函数的返回值 因为它就是调用函数

     - apply（） - 理解

         - 使用apply方法调用函数 同时指定被调用函数中this的值
         - 语法：fun.apply(thisArg,[srgsArray])
         - thisArg:在fun函数运行时指定的this值
         - argsArray:传递的值 必须包含在数组里面
         - 返回值就是函数的返回值 因为它就是调用函数
         - 因此apply主要跟数组有关系 比如使用Math.max（）求数组的最大值

     - bind（） - 重点

          - bind（）方法不会调用函数 但是能改变函数内部this指向
          - 语法：fun.bind(thisArg,arg1,arg2,...)
          - thisArg:在fun函数运行时指定的this值
          - arg1，arg2：传递的其他参数
          - 返回由指定的this值和初始化参数改造的原函数拷贝（新函数）
          - 因此当我们只是想改变this指向 并且不想调用这个函数的时候 可以使用bind  比如改变定时器内部的this指向

     - call apply bind总结

         - 相同点：都可以改变函数内部的this指向
         - 区别点：
          
            -  call和apply会调用函数 并且改变函数内部this指向
            -  call和apply传递的参数不一样 call传递参数arg1，arg2形式 apply必须是数组形式【arg】
            -  bind不会调用函数 可以改变函数内部this指向

         - 主要应用场景

            - call调用函数并且可以传递参数
            - apply经常跟数组有关系 比如借助于数学对象实现数组最大值最小值
            - bind不调用函数 但还是想改变this指向 比如改变定时器内部的this指向

**4.性能优化**

   - 防抖（debounce）

       - 指触发事件后在n秒内函数只能执行一次 如果在n秒内又触发了事件 则会重新计算函数执行时间
       - 单位时间内 频繁触发事件 只执行最后一次
       - 开发场景：搜索框防抖

           - 假设输入就可以发送请求 但是不能每次输入都去发送请求 输入比较快发送请求会比较多
           - 我们设定一个时间，假如300ms， 当输入第一个字符时候，300ms后发送请求，但是在200ms的时候又输入了一个字符，则需要再等300ms 后发送请求

  -   节流（throttle）
     
      - 指连续触发事件但是在n秒钟只执行一次函数          
        
          
       